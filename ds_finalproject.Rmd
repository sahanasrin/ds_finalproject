---
title: "Final Project"
author: "Sahana Srinivasan, Jake Kochmansky, Jae Gnazzo, Nathaniel Spilka"
output: html_document
---

# _________________________________________________

# PPOL 670 | Final Project

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#code for clearing up workspace
rm(list = ls(all.names = TRUE))
graphics.off()
cat("\014")

#loading in all relevant packages 
library(tidycensus)
library(tidyverse)
library(tidymodels)
library(parsnip)
library(recipes)
library(ranger)
library(yardstick)
library(vip)
library(stringr)
library(sf)
library(janitor)
library(censusapi)
library(jsonlite)
library(httr)
library(usmap)
library(here)
library(mapview)
library(ggthemes)
library(tigris)
#library(albersusa)
library(ggiraph)
library(srvyr)
```

#Census API Query Method 1 and Column Name Clean-Up
```{r}
#creating dataset 
#census api key
#Sys.getenv("CENSUS_API_KEY")

#load in state variable list
states = c("CA", "OR", "WA", "NV", "AZ", "CO", "ID", "MT", "WY", "NM", "AK", "HI","UT",
           "ND", "SD", "NE", "KS", "MN", "IA", "MO", "WI", "IL", "IN", "MI", "OH",
           "OK", "TX", "LA", "AR", "MS", "AL", "GA", "FL", "TN", "KY", "WV", "VA", "NC", "SC", "DE","MD",
           "ME", "NH", "VT", "MA", "CT", "RI", "NJ", "PA", "NY")

#browse variable names 
variables_2017 <- load_variables(2017, "acs5", cache = TRUE)

#use get_acs method to retrieve desired data on all 50 states 
states_2017 <- get_acs(
  geography = "tract",
  variables = c(total_pop = "B01003_001", #total population
                #income_pov = "C17002_001", #income to poverty ratio
                #weeks_work_alloc = "B99234_001", #allocation of weeks worked in the past 12 months
                #hours_week_work_alloc = "B99233_001", #allocation of usual hours worked per week in the past 12 months 
                travel_min_work_agg = "B08133_001", #aggregate travel time to work in minutes
                female_count = "B01001_026", #total female
                computer_count ="B28010_001", #computers in household
                #female_marital_alloc = "B99131_001", #allocation of marital status for females
                #travel_work = "B08303_001", #travel time to work
                education_alloc = "B99151_001", #allocation of educational attainment (number of people who have completed HS)
                med_income = "B19013_001", #median income level in last 12 months (this is our outcome variable)
                hs_count = "B15003_017", #number of people with a HS diploma
                ged_count = "B15003_018", #number of people with a ged
                assoc_count = "B15003_021", #number of people with an associates degree
                bach_count= "B15003_022" #number of people with bachelor's degree
                ), 
  output = "wide",
  state = states,
  year = 2017) # data from years 2013 - 2017

#renaming geoid and name columns 
states_2017 <- states_2017 %>%
  rename(geoid = GEOID,
         name = NAME)

#drop the E estimate columns
for ( col in 1:ncol(states_2017)){
    colnames(states_2017)[col] <-  sub("E.*", "", colnames(states_2017)[col])
    }
```

#Read in Childhood Opportunity Dataset and Join Census Data with New Dataset
```{r}
#reading in childhood opportunity data 
child_opp_data1 <- read_csv("data/index.csv")

#clean childhood opportunity data 
child_opp_data2 <- child_opp_data1 %>%
  na.omit(child_opp_data1) %>%
  filter(year == 2015) %>%
  select(geoid, pop, msaname15, z_ED_nat, z_HE_nat, z_COI_nat) %>%
  clean_names()

#joining the census and COI data
states_2017 <- left_join(states_2017, child_opp_data2, by= "geoid")
```

##Cleaning the states_2017 joined dataset
```{r - cleaning data}
#removing all NAs
states_2017 <- na.omit(states_2017)

#making all variables log
states_2017 <- states_2017 %>%
  mutate(
    log_total_pop = log(total_pop),
    log_travel_min_work_agg = log(travel_min_work_agg),
    log_female_count = log(female_count),
    log_computer_count = log(computer_count),
   #log_travel_work = log(travel_work),
    log_education_alloc = log(education_alloc),
    log_med_income = log(med_income),
    log_hs_count = log(hs_count),
    log_ged_count = log(ged_count),
    log_assoc_count = log(assoc_count),
    log_bach_count = log(bach_count)
    )

#only using the numbers for the recipe
only_numb <- states_2017 %>%
  select(starts_with("log_"), starts_with("z"))

# only_numb <- states_2017 %>%
#   select(-geoid, -name, -pop, -msaname15, -ends_with("M"))

#removing inf
only_numb <- only_numb %>%
  filter_all(all_vars(!is.infinite(.)))
```

#Generate a Variable List For Upcoming EDA
```{r - variables}
#For variables: E = estimate, M = margin of error
#aggregate 

# B01003_001 = total population
# C17002_001 = income to poverty ratio
# B992518_001 = allocation of gross rent
# B99234_001 = allocation of weeks worked in the past 12 months
# B99233_001 = allocation of usual hours worked per week in the past 12 months 
#list of variables ---------------
variable_list = c('total_pop', 
                  #'income_pov', 
                  #'weeks_work_alloc', 
                  #'hours_week_work_alloc', 
                  'travel_min_work_agg', 
                  'female_count',
                  'computer_count', 
                  #'female_marital_alloc', 
                  'travel_work', 
                  'education_alloc',
                  'hs_count',
                  'ged_count',
                  'assoc_count',
                  'bach_count')
```

#Sahana EDA (Some visualizations that tell the story in a slightly clearer way)
```{r EDA}
#finding number of people in different income brackets
states_2017_EDA <- states_2017 %>% 
  mutate(
    income_bracket = case_when(
    med_income <= 25161 ~ "Lower", 
    med_income <= 78624 ~ "Lower-Median", 
    med_income <= 186151 ~ "Median-Upper", 
    TRUE ~ "Upper") 
  )

states_2017_EDA %>%
  ggplot(mapping = aes(x = income_bracket, y = total_pop)) + 
  geom_col() +
  labs (
    title = "Number of People in the United States in Specified Income Brackets", 
    subtitle = "Employment Figures From April 2021", 
    x = "Income Bracket", 
    y = "Number of People", 
    caption = ""
  )

#finding proportion of census tracts in specified income bracket 
states_2017_EDA %>% 
  mutate(lower_income = if_else(income_bracket == "Lower", 1, 0)) %>% #gen dummy variable 
  mutate(lower_median_income =if_else(income_bracket == "Lower-Median", 1, 0)) %>%
  mutate(median_upper_income = if_else(income_bracket == "Median-Upper",0, 1)) %>%
  #filter(AGE>=16) %>% #remove respondents less than or equal to 16 
  #group_by(YEAR) %>% 
  summarize(
    lower_income = sum(lower_income == 1), 
    lower_median_income = sum(lower_median_income == 1), 
    median_upper_income = sum(median_upper_income == 1)  
  )

#group by income bracket - find number of computers per category 
#lower level of computers among lower income - this bracket is underrepresented in the data comparatively speaking
computers_viz <- ggplot(states_2017_EDA, aes(x="", y=computer_count, fill=income_bracket)) +
  geom_bar (width = 1, stat = "identity")
computers_viz <- computers_viz + coord_polar("y", start=0)
computers_viz 

#group by income bracket - create a boxplot
#maybe you should filter by in this 
travel_time_viz <- ggplot(states_2017_EDA, aes (x = travel_min_work_agg, y = income_bracket)) + 
  geom_boxplot()
travel_time_viz

#making it interactive??? 
#girafe(ggobj1 = computers_viz) %>%
  #girafe_options(opts_hover(css = "fill:blue;"))
```

#Jake EDA
```{r EDA}
#EDA for all states

#all states
#means of variables for all states
means = colMeans(states_2017[,c(variable_list)])
barplot(means[order(means,decreasing=T)])


means = colMeans(states_2017[,c(variable_list)])
barplot(means[order(means,decreasing=T)])

summary(states_2017$med_income)
states_2017 %>%
  ggplot(aes(med_income)) +
  geom_freqpoly(binwidth = 1000) + 
  labs(x = "Median Income",
       y = "Count",
       title = "Distribtion of Travel Time by Census Tract"
  )

summary(states_2017$travel_work)
states_2017 %>%
  ggplot(aes(travel_work)) +
  geom_freqpoly(binwidth = 60) + # 60 seconds = 1 minute
  labs(x = "Seconds Traveled to Work",
       y = "Count",
       title = "Distribtion of Travel Time by Census Tract"
  )

summary(states_2017$travel_min_work_agg)
states_2017 %>%
  ggplot(aes(travel_work)) +
  geom_freqpoly(binwidth = 60) + # 60 seconds = 1 minute
  labs(x = "Seconds Traveled to Work",
       y = "Count",
       title = "Distribtion of Travel Time by Census Tract"
  )

summary(states_2017$computer_count)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Computer Count by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$female_count)
states_2017 %>%
  ggplot(aes(female_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total Women by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$total_pop)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total Population by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$hs_count)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total High School Degrees by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$ged_count)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total GED by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$assoc_count)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total Associate's Degree by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$bach_count)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = "Total Bachelor's Degree by Census Tract") +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

summary(states_2017$education_alloc)
states_2017 %>%
  ggplot(aes(computer_count, 1)) +
  geom_point(alpha = 0.2) +
  scale_y_continuous(breaks = 0) +
  labs(y = NULL) +
  theme_bw() +
  theme(panel.border = ggplot2::element_blank())

#med income
states_2017 %>%
  ggplot(aes(
      x = travel_work,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = travel_min_work_agg,
      y = med_income))+
  geom_point() +
  labs(x = "Total Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = total_pop,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = female_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = computer_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = med_income))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#total pop
states_2017 %>%
  ggplot(aes(
      x = female_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = computer_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = female_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = travel_min_work_agg,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = travel_work,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = total_pop))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#Travel min work agg
states_2017 %>%
  ggplot(aes(
      x = female_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = computer_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = travel_work,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = travel_min_work_agg))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Median Income",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#female count
states_2017 %>%
  ggplot(aes(
      x = computer_count,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = travel_work,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = female_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#computer count
states_2017 %>%
  ggplot(aes(
      x = travel_work,
      y = computer_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = computer_count))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Computers in Census Tract",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = computer_count))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Computers in Census Tract",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = computer_count))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Computers in Census Tract",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = computer_count))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Computers in Census Tract",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = computer_count))+
  geom_point() +
  labs(x = "Seconds Traveled to Work",
       y = "Computers in Census Tract",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#travel work
states_2017 %>%
  ggplot(aes(
      x = hs_count,
      y = travel_work))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = travel_work))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = travel_work))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = travel_work))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = travel_work))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#hs_count
states_2017 %>%
  ggplot(aes(
      x = ged_count,
      y = hs_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = hs_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = hs_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = hs_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#ged_count
states_2017 %>%
  ggplot(aes(
      x = assoc_count,
      y = ged_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = ged_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = ged_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = ged_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#assoc_count
states_2017 %>%
  ggplot(aes(
      x = bach_count,
      y = assoc_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = assoc_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

#education alloc
states_2017 %>%
  ggplot(aes(
      x = education_alloc,
      y = bach_count))+
  geom_point() +
  labs(x = "",
       y = "",
       title = "TBD") +
  geom_smooth(method=lm, se=FALSE)

```

## splitting the data, creating folds, and creating a recipe (that will need to get updated depending on variables used)
```{r - Splitting and folding and creating a recipe}
#Set up a testing environment
#set the seed and split the data
set.seed(20211101)
states_2017_split <- initial_split(only_numb, prop = .8)
states_2017_train <- training(states_2017_split)
states_2017_test <- testing(states_2017_split)

#resampling with 10 folds
folds <- vfold_cv(data = states_2017_train, v = 10)

#what other steps would be good to include here? *** UPDATE ACORDING TO THE VARIABLES USED
states_2017_rec <- recipe(log_med_income ~ ., data = states_2017_train) %>%
  step_naomit(all_predictors()) %>%
  step_nzv(all_predictors()) %>%
  step_filter_missing(all_predictors()) 


# %>%
#   step_log(-starts_with("z_"), all_predictors(), all_outcomes()) %>%
#   step_naomit(all_predictors()) %>%
#   step_rm(contains("nf")) %>%
#   prep(training = states_2017_train)
#  temp <- bake(states_2017_rec, new_data = NULL)

```

## linear regression model *infrastructure*
```{r - linear regression model}
#setting the linear reg model
lm_mod <- linear_reg() %>%
  set_engine(engine = "lm") %>%
  set_mode(mode = "regression")

#workflow - (we don't use prep when we run the recipe here)
lm_wf <- workflow() %>%
  add_recipe(recipe = states_2017_rec) %>%
  add_model(spec = lm_mod)

#resampling using the 10-v-fold process specified above
lm_cv <- lm_wf %>%
  fit_resamples(resamples = folds)

#using RMSE to choose the best model
lm_best <- lm_cv %>%
  select_best("rmse")

#finalize the workflow using the established workflow and the best model (according to RMSE)
lm_final <- lm_wf %>%
  finalize_workflow(parameters = lm_best)

#fitting the workflow with the original data
lm_fit <- lm_final %>%
  fit(states_2017_train)

#RMSE looks consistent across folds
collect_metrics(lm_cv, summarize = FALSE) %>%
  filter(.metric == "rmse") %>%
  ggplot(mapping = aes(x = id, y = .estimate, group = .estimator, label = round(.estimate, digits = 2))) +
  geom_line() +
  geom_point() +
  geom_label(hjust = .1, nudge_y = -.02) +
  scale_y_continuous(limits = c(0, .3)) +
  labs(title = "Median Income: Linear Regression Model (RMSE Across 10 Folds)", 
       y = "Predicted RMSE",
       x = "Fold Number") +
  theme_minimal()

#mean RMSE across the 10 samples
collect_metrics(lm_cv) %>%
  filter(.metric == "rmse") %>%
  select(mean) %>%
  pull(mean)

lm_fit %>%
  extract_fit_parsnip() %>%
  vip(num_features = 10)

```

## K nearest neighbors model *infrastructure* 
```{r - Exercise 02: knn model}
knn_mod <- nearest_neighbor(neighbors = 5) %>%
  set_engine(engine = "kknn") %>%
  set_mode(mode = "regression")

#workflow situation
knn_workflow <- workflow() %>%
  add_model(spec = knn_mod) %>%
  add_recipe(recipe = states_2017_rec)

#creating a tuning grid
#knn_grid <- tibble(neighbors = seq(from = 15, to = 27, by = 2))

#resampling using the 10-v-fold process specified above
knn_res <- knn_workflow %>%
  fit_resamples(resamples = folds)

#using RMSE to choose the best model
knn_best <- knn_res %>%
  select_best("rmse")

#finalize the workflow using the established workflow and the best model (according to RMSE)
knn_final <- knn_workflow %>%
  finalize_workflow(parameters = knn_best)

#fitting the workflow with the original data
knn_fit <- knn_final %>%
  fit(states_2017_train)

#applying the updated workflow to the fit across folds
knn_fit_rs <- knn_final %>%
  fit_resamples(resamples = folds)

#RMSE looks consistent across folds
collect_metrics(knn_res, summarize = FALSE) %>%
  filter(.metric == "rmse") %>%
  ggplot(mapping = aes(x = id, y = .estimate, group = .estimator, label = round(.estimate, digits = 2))) +
  geom_line() +
  geom_point() +
  geom_label(hjust = .1, nudge_y = -.02) +
  scale_y_continuous(limits = c(0, .3)) +
  labs(title = "Median Income: KNN Model (RMSE Across 10 Folds)", 
       y = "Predicted RMSE",
       x = "Fold Number") +
  theme_minimal()

#mean RMSE across the 10 samples
collect_metrics(knn_res) %>%
  filter(.metric == "rmse") %>%
  select(mean) %>%
  pull(mean)

```

## Random forest model *infrastructure*
```{r - Exercise 02: random forest model}
treeNumb <- 1000
gridVal <- 10
#since random forests can be computationally heavier, we use parallel processing
cores <- parallel::detectCores()

#random forest with 1000 iterations while utilizing the parallel processing (num.threads = cores)
rf_mod1 <- rand_forest(mtry = tune(), min_n = tune(), trees = treeNumb) %>% 
  set_engine(engine = "ranger", num.threads = cores, importance = "impurity") %>%
  set_mode("regression")

#initiating the workflow for random forests
rf_workflow1 <- workflow() %>% 
  add_recipe(recipe = states_2017_rec) %>%
  add_model(spec = rf_mod1)

#tune with the given number of folds and grid-value
rf_res <- rf_workflow1 %>% 
  tune_grid(resamples = folds, grid = gridVal,
            control = control_grid(save_pred = TRUE))

#these are the best hyperparameters (mtry = , min_n = )
rf_best <- rf_res %>% 
  select_best(metric = "rmse")

#applying the best hyperparameters to our original workflow (since we used tune() as "place holders" for mtry and min_n)
rf_final <- rf_workflow1 %>%
  finalize_workflow(parameters = rf_best)

#apply the worlflow when fitting the data
rf_last_fit <- rf_final %>%
   last_fit(states_2017_split)

#fitting the workflow with the original data
rf_final_fit <- fit(rf_final, only_numb)

#applying the updated workflow to the fit
rf_fit_rs <- rf_final %>%
  fit_resamples(resamples = folds)

#RMSE looks consistent across folds
collect_metrics(rf_fit_rs, summarize = FALSE) %>%
  filter(.metric == "rmse") %>%
  ggplot(mapping = aes(x = id, y = .estimate, group = .estimator, label = round(.estimate, digits = 2))) +
  geom_line() +
  geom_point() +
  geom_label(hjust = .1, nudge_y = -.02) +
  scale_y_continuous(limits = c(0, .3)) +
  labs(title = "Median Income: Random Forest Model (RMSE Across 10 Folds)", 
       y = "Predicted RMSE",
       x = "Fold Number") +
  theme_minimal()

#mean RMSE across the 10 samples
collect_metrics(rf_fit_rs) %>%
  filter(.metric == "rmse") %>%
  select(mean) %>%
  pull(mean)

```

## Prediction *infrastructure*
```{r - prediction for linear regression}
#making a prediction
predictions_testing <- bind_cols(states_2017_test,
    predict(object = lm_fit, new_data = states_2017_test)
  )
predictions_testing

#rmse for test data
rmse(data = predictions_testing, truth = states_2017_test$log_med_income, estimate = .pred)


```

## geospatial/advanced data viz
```{r}
#load in income data from census - we won't need this once we finalize the earlier sections
map_inc <- tidycensus::get_acs(
  geography = "state", 
  variables = c(med_income = "B19013_001"), 
  output = "wide", 
  year = 2017) %>%
  janitor::clean_names() %>%
  select(med_income_e, name)

#loading in the mad that looks best and removing all population-related columns
map_US <- usa_sf("lcc") %>%
  select(-starts_with("pop")) 

#here we're fusung the income and state data - this won't be needed later on
map_US_inc <- left_join(map_US, map_inc, by = "name")

#this is where we'll put all relevant data that will appear when we hover over a state
map_US_inc <- map_US_inc %>% 
  mutate(median_income = med_income_e,
         hoverText = paste0("State: ", as.character(name), "\n", 
                            "Median Income: ", as.character(median_income), "\n", 
                            "Predicted Median Income: ", as.character(census_area), "\n",
                            "COI z-score: ", as.character(iso_3166_2), "\n",
                            "Health z-score: ", as.character(fips_state)))

#here's the figure - we can come back and make it look prettier if needed
map1 <- map_US_inc %>%
  ggplot() +
  geom_sf_interactive(size = 0.2, color = "white", aes(fill = median_income,
    data_id = hoverText, tooltip = hoverText)) +
  labs(fill='Median Income') +
  theme_void()

#this initializes the interactive bit
girafe(ggobj = map1) %>%
  girafe_options(opts_hover(css = "fill:blue;"))
```

## geospatial work beginnings - experimenting with what works and what doesn't
Advanced data visualization (e.g., interactive visualization)
```{r}
#a more replicable way to download the data - make sure you have a "data" folder in your "ds_finalproject" folder
dataFile <- here("data", "states.zip")
dataFolder <- here("data")
download.file("https://www2.census.gov/geo/tiger/GENZ2017/shp/cb_2017_us_state_500k.zip", destfile = dataFile)
unzip(dataFile, exdir = dataFolder)

#loading in census states shape file
#we don't use this shape file anywhere yet 
geoCensusStates <- st_read("data/cb_2017_us_state_500k.shp") %>%
  clean_names()

#setting the CRS
# censusStateShaFile <- geoCensusStates %>%
#   select(geoid, geometry) %>%
#   st_set_crs(value = 4326)

#combining the Census shapefile witht he median household income by state
#HERE WE'LL NEED TO HAVE CREATED A A DATAFRAME WITH THE MEDIAN INCOME AND PREDICTED MEDIAN INCOME FOR EACH STATE
#censusGeoData <- st_join(censusStateShaFile, , join = st_intersects)

#setting the crs and creating the geometry variable
# censusStateShaFile <- geoCensusStates %>%
#   st_as_sf(coords = c("longitude", "latitude"), na.fail = FALSE) %>%
#   st_set_crs(value = 4326)

#Map idea 1 - this may allow for more changes down the line
geoCensusStates %>% 
  ggplot() +
  geom_sf() +
  coord_sf(crs = 5070, datum = NA) +
  theme_map()

#map idea 2
library(maps)
us_states <- map_data("state")
head(us_states)

p <- ggplot(data = us_states,
            mapping = aes(x = long, y = lat,
                          group = group))

p + geom_polygon(fill = "white", color = "black") +
  theme_map()

```

## Census API Query Method 2 (via a url query) to pull median income and some basic mapping exploration
##I'll use this to create the unsupervised ml model so no deletions necessary yet 
```{r}
#use census API Query to get data on median household income levels in 50 states
#i'm not really using this anywhere yet 
#DON'T DELTE 
url <- str_glue("https://api.census.gov/data/2017/acs/acs5?get=NAME,B06011_001E&for=state:*")
popurl <- GET(url = url)
http_status(popurl)
popurl <- content(popurl, as = "text")
pop_matrix <- fromJSON(popurl)
#turn body of character matrix into a tibble
us_50_states <- as_tibble(pop_matrix[2:nrow(pop_matrix),],.name_repair = "minimal")
#add variable names to the tibble
names(us_50_states) <- us_50_states[1,]

#this is just me trying to create example maps using a different type of package
# ca_example_map <- get_acs(
#   geography = "tract",
#   variables = c(total_pop = "B01003_001", #total population
#                 #income_pov = "C17002_001", #income to poverty ratio
#                 #weeks_work_alloc = "B99234_001", #allocation of weeks worked in the past 12 months
#                 #hours_week_work_alloc = "B99233_001", #allocation of usual hours worked per week in the past 12 months 
#                 #travel_min_work_agg = "B08133_001", #aggregate travel time to work in minutes
#                 #female_count = "B01001_026", #total female
#                 #computer_count ="B28010_001", #computers in household
#                 #female_marital_alloc = "B99131_001", #allocation of marital status for females
#                 #travel_work = "B08303_001", #travel time to work
#                 #education_alloc = "B99151_001", #allocation of educational attainment (number of people who have completed HS)
#                 med_income = "B19013_001" #median income level (this is our outcome variable)
#                 ), 
#   output = "wide",
#   state = states,
#   year = 2017) # data from years 2013 - 2017

us_map <- tidycensus::get_acs(
  geography = "state", 
  variables = c(total_pop = "B01003_001", 
                med_income = "B19013_001"), 
  output = "wide", 
  state = states, 
  geometry = TRUE, 
  year = 2017) 

plot(us_map["med_incomeE"])
       
#plot(ca_example_map["med_incomeE"])

#this is an interactive map
library(mapview)
mapview(us_map, zcol = "med_incomeE")
```

#Unsupervised Machine Learning Models 
```{r - unsupervised clustering}

```